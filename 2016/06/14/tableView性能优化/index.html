<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> TableView性能与reusableCell · partyspy的技术博客</title><meta name="description" content="TableView性能与reusableCell - partyspy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">TableView性能与reusableCell</h1><div class="post-info">Jun 14, 2016</div><div class="post-content"><p>这是笔者在工作项目中遇到的一个需求。本篇文章将延续上一篇<a href="http://0.0.0.0:4000/2016/06/14/TableViewCell%E7%9A%84%E6%94%B6%E7%BC%A9%E5%B1%95%E5%BC%80%E4%B8%8E%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/" target="_blank" rel="external">《TableViewCell的收缩展开与动态高度》</a>继续探讨有关TableView性能方面的问题。<a href="http://0.0.0.0:4000/2016/06/14/TableViewCell%E7%9A%84%E6%94%B6%E7%BC%A9%E5%B1%95%E5%BC%80%E4%B8%8E%E5%8A%A8%E6%80%81%E9%AB%98%E5%BA%A6/" target="_blank" rel="external">上一篇</a>中主要涉及到了<code>-beginUpdate</code>触发<code>-tableView:heightForRowAtIndexPath:</code>回调去改变Cell高度，和通过改变Cell中内容的<strong>约束优先级</strong>去解决约束冲突问题，以及StackView在TableViewCell里的运用。</p>
<h3 id="TableView性能"><a href="#TableView性能" class="headerlink" title="TableView性能"></a>TableView性能</h3><p>table view性能瓶颈主要集中在<code>-tableView:cellForRowAtIndexPath</code> 和<code>-tableView:heightForRowAtIndexPath:</code>这两个高频调用的回调函数。<a href="http://www.jianshu.com/p/202b5cfcc6f4" target="_blank" rel="external">上一篇</a>文章中将Cell的stackView内容插入和高度计算都移到了<code>-tableView:didSelectRowAtIndexPath:</code>里，且加了判断标识使得每个cell只计算一次。这也涉及到了性能优化的实践。</p>
<blockquote>
<p>不要在<code>-tableView:heightForRowAtIndexPath:</code>里使用tableView的 <code>-cellForRowAtIndexPath:</code>方法获取cell.</p>
</blockquote>
<p><em>然而这里还是存在一个问题。</em></p>
<h4 id="reuseIdentifier"><a href="#reuseIdentifier" class="headerlink" title="reuseIdentifier"></a>reuseIdentifier</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *cellID = <span class="string">@"MyCellID"</span>;</span><br><span class="line">    </span><br><span class="line">    MyCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID forIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">    [cell loadSumLineByDict:<span class="keyword">self</span>.dataList[indexPath.row]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于<strong>reuseIdentifier</strong>: 我们知道，每一个tableView维护了一个可重用cell的缓存池，当cell视图移出屏幕时，tableView并没有将该cell对象丢弃而是放入缓存池，而当新的cell移入屏幕时调配给其使用。但是请<strong>注意</strong>拥有相同的 <em>resueIdentifier</em> 的cell并不代表是同一个对象cell，实际上<code>-dequeueReusableCellWithIdentifier:</code>依然会生成至少屏幕一次能容纳下的不同Cell对象个数。而<code>reuseIdentifier</code>更多的是用来界定一种Cell的<em>类型</em>（或形式）。</p>
</blockquote>
<p>本例中Cell的类型都为<code>MyCell</code>没错，实际上涉及到动态插入内容到Cell，每个Cell实际上拥有的高度与内容都不一样了。如果它们依然使用同一个<code>reuseIdentifier</code>的话，将会出现不同Cell内容重复到一块的现象。</p>
<blockquote>
<p>比如，该tableView有15个Cell而屏幕一次能容纳10个Cell，滑动时第1个cell移出屏幕，第11个Cell将移入屏幕，从而重用了第1个Cell的对象。而每一行的展开数据是否已加载的标识是由IndexPath去匹配的，所以即便第11个Cell（即第1个Cell对象）已载入过展开内容，select第11行时依然会加载第11行应有的展开内容。因此再度滑动回第1行时，展开内容已经包括了自己原本以及第11行的信息，第11行亦然。</p>
</blockquote>
<p><strong>所以每一行Cell我们都应该使之为不同对象。</strong></p>
<p>但是要放弃使用cell可重用机制吗？当然不是，那样性能将难以承受。我们使所有cell都拥有不同的<code>reuseIdentifier</code>来重用。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyTableViewController.m</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    <span class="comment">// _dataList为展示数据模型，可确定表格行数。</span></span><br><span class="line">    [<span class="keyword">self</span> registerCellsByCount:<span class="keyword">self</span>.dataList.count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//批量注册可重用cell</span></span><br><span class="line">- (<span class="keyword">void</span>)registerCellsByCount:(<span class="built_in">NSInteger</span>)count &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cellReuseID;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;count; ++i) &#123;</span><br><span class="line">        cellReuseID = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"MyCell%d"</span>, i];</span><br><span class="line">        [<span class="keyword">self</span>.tableView registerNib:[<span class="built_in">UINib</span> nibWithNibName:<span class="string">@"MyCell"</span> bundle:<span class="literal">nil</span>]</span><br><span class="line">             forCellReuseIdentifier:cellReuseID];</span><br><span class="line">        [<span class="keyword">self</span>.cellReuseIdArray addObject:cellReuseID];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此我们注册了<code>reuseIdentifier</code>为<em>MyCell1</em>, <em>MyCell2</em>, …, <em>MyCelln</em>的一批可重用Cell，而每个Cell的重用仅面向自己对应的row的Cell。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line"></span><br><span class="line">    MyCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="keyword">self</span>.cellReuseIdArray[indexPath.row] forIndexPath:indexPath];</span><br><span class="line">    </span><br><span class="line">    [cell loadSumLineByDict:<span class="keyword">self</span>.dataList[indexPath.row]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在页面Cell不是特别多且每行Cell之间不能相互复用的情况下，提供一种思路给大家借鉴。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/06/14/TableViewCell的收缩展开与动态高度/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">partyspy</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>