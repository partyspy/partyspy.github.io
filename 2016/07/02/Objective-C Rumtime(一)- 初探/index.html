<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Objective-C Runtime(一) 初探 · partyspy的技术博客</title><meta name="description" content="Objective-C Runtime(一) 初探 - partyspy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/partyspy.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/partyspy.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/partyspy" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/partyspy" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Objective-C Runtime(一) 初探</h1><div class="post-info">Jul 2, 2016</div><div class="post-content"><blockquote>
<p>Objective-C 编译器与运行时系统支撑着OC程序的运行。</p>
</blockquote>
<a id="more"></a>
<p>Objective-C程序在三个层面上与runtime系统交互：</p>
<ul>
<li><p>Objective-C源代码：编译器把OC代码类、方法、成员变量等信息转化为支持语言动态特性的数据结构与函数。比如消息传递机制中的核心函数<code>objc_msgSend</code>，即由OC代码的消息传递语句转换而来。</p>
</li>
<li><p>NSObject提供了一系列的自省(Introspection)方法，也是运行时的一部分。</p>
</li>
<li>Runtime函数。</li>
</ul>
<h2 id="消息传递机制"><a href="#消息传递机制" class="headerlink" title="消息传递机制"></a>消息传递机制</h2><p>在Objective-C里，消息(message)是到运行时才绑定到方法实现的.<br>意思就是说, 像</p>
<p><code>[receiver message];</code></p>
<p>这样一条语句, 编译器会把他转换为</p>
<p><code>objc_msgSend(receiver, selector);</code></p>
<p>这样第一个C语言的函数调用, 参数分别是消息接受者(对象), 消息对应的方法名称(选择子), 若改方法带参数, 则为</p>
<p><code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code></p>
<p>该函数的动态绑定过程是这样的:</p>
<ul>
<li>它首先沿着类的继承体系去寻找选择子对应的方法实现. </li>
<li>找到后调用具体的方法实现, 并把对象指针以及各参数传递给该方法, 随后调用它. </li>
<li>最后返回该方法的返回值.</li>
</ul>
<p>它的函数原型：</p>
<p><code>id objc_msgSend(id self, SEL cmd, ...)</code></p>
<p>回头看动态绑定过程的第一步.<br>Objective-C里, 每个类里都维护着一张表格(<em>dispatch table</em>), 其中的指针正是指向该类下所定义的方法实现, 而方法的选择子(<em>selector</em>)作为查表用的”键”.<br>每个类里除了该表之外, 还拥有一个指向其父类的指针.</p>
<p>这些类与对象的结构是这样的:</p>
<p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt=""></p>
<p>对象实例里有一个<code>isa</code>指针, 指向它的类对象.</p>
<p><code>objc_msgSend</code>函数依赖着上述的继承体系去查找并调用恰当的方法.</p>
<blockquote>
<p>为了加速方法的查找, 每个类里除了自身定义的方法列表外, 还维护这一张快速映射表作为缓存. 多次对它查找同一selector将不再向上追溯查找, 而直接查找本身的缓存并返回对应的方法实现.</p>
</blockquote>
<p>刚才提到要调用的方法实现, 每个OC对象的方法都可视为一个C函数, 其原型如下: </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;return_type&gt; Class_selector(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, ...)</span><br></pre></td></tr></table></figure>
<p>实际函数名可能跟上面的不一样. 但注意的是该函数里是包括了<code>self</code>和<code>_cmd</code>两个隐含参数的. 所谓”隐含”, 是指在开发人员编写的方法代码里, 是不存在这两个参数, 但我们都可以通过这两个变量名去访问.</p>
<h2 id="消息转发机制"><a href="#消息转发机制" class="headerlink" title="消息转发机制"></a>消息转发机制</h2><p>在上一节消息<strong>传递</strong>机制中, 对象接收到一个消息后, 去搜寻其对应方法实现的函数地址. 若搜寻不到, 并不马上抛出异常, 而是再给接受者一次机会, 进入<strong>消息转发</strong>机制.</p>
<p>消息转发分为两大阶段. 第一阶段先征询接受者所属的类, 看其是否能动态添加方法, 以处理当前这个未知的选择子(unknown selector), 这叫做<strong>动态方法解析</strong>(<em>Dynamic Method Resolution</em>); 第二阶段则为”<strong>完整的消息转发机制”</strong>(<em>full forwarding mechanism</em>).</p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>对象在收到无法解读的消息后, <strong>首先</strong>将调用其所属类的下列类方法:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)selector</span><br></pre></td></tr></table></figure>
<p>顾名思义, 该方法作用为解析实例方法, 相应地也有个类似的方法, 为解析类方法所用: <code>resolveClassMethod</code>.<br>此方法在<code>respondsToSelector:</code> 或<code>instancesRespondToSelector:</code>被调用后返回前, 也有一次机会为自己动态添加一个方法的实现.</p>
<p>动态方法解析常用来实现 @dynamic 属性.</p>
<p>下面看一个完整的例子演示动态方法解析.</p>
<p>假设要编写一个类似”字典”的对象, 它里面可以容纳其它对象, 只不过开发者要直接通过属性来存取其中的数据. 这个类的设计思路是: 有开发者来添加属性定义, 并将其声明为 @dynamic, 类则会自动处理相关属性值的存放与获取操作. 听起来不错吧? &gt;_&lt;</p>
<p>类的接口定义如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AutoDictionary</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *string;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *number;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *date;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> opaqueObject;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这个类将装载各种不同类型的对象, 看起来与平时普通的类没啥区别啊? 我们看类的实现.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"AutoDictionary.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AutoDictionary</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *backingStore;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AutoDictionary</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@dynamic</span> string, number, date, opaqueObject;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _backingStore = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明各属性为 <em>@dynamic</em>, 编译器不会自动为property生成存取方法和实例变量. 由我们自行实现.</p>
<p>关键在于<code>resolveInstanceMethod:</code>方法的实现.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *selString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selString hasPrefix:<span class="string">@"set"</span>]) &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoDictionarySetter, <span class="string">"v@:@"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, sel, (IMP)autoDictionaryGetter, <span class="string">"@@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>众所周知, 任何的点语法访问都会转化为名为<code>&lt;name&gt;</code>, <code>set&lt;Name&gt;</code>形式的存取方法来访问, 以上使用<code>class_addMethod</code>在运行时添加存取方法, 所有属性将共用这一对getter与setter. </p>
<p><code>class_addMethod</code>函数第一和第二参数分别为类对象自身与选择子, 第三个参数为待添加方法实现对应的函数指针, 第四为待添加方法的”<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">类型编码</a>“, 指定该添加方法的参数与返回值等.</p>
<p>使用<code>class_addMethod</code>动态添加方法后, 所添加的方法将一直在运行时存在, 下一次的调用该方法将不再进行动态方法解析.</p>
<p>下面实现getter与setter:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getter</span></span><br><span class="line"><span class="keyword">id</span> autoDictionaryGetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="comment">// Get the backing store from the object</span></span><br><span class="line">    AutoDictionary *typedSelf = (AutoDictionary*)<span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *backingStore = typedSelf.backingStore;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The key is simply the selector name</span></span><br><span class="line">    <span class="built_in">NSString</span> *key = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return the value</span></span><br><span class="line">    <span class="keyword">return</span> [backingStore objectForKey:key];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setter</span></span><br><span class="line"><span class="keyword">void</span> autoDictionarySetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="comment">// Get the backing store from the object</span></span><br><span class="line">    AutoDictionary *typedSelf = (AutoDictionary*)<span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *backingStore = typedSelf.backingStore;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** The selector will be for example, "setOpaqueObject:".</span><br><span class="line">     *  We need to remove the "set", ":" and lowercase the first</span><br><span class="line">     *  letter of the remainder.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(_cmd);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *key = [selectorString mutableCopy];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Remove the `:' at the end</span></span><br><span class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(key.length - <span class="number">1</span>, <span class="number">1</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Remove the `set' prefix</span></span><br><span class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">3</span>)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Lowercase the first character</span></span><br><span class="line">    <span class="built_in">NSString</span> *lowercaseFirstChar = [[key substringToIndex:<span class="number">1</span>] lowercaseString];</span><br><span class="line">    [key replaceCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:lowercaseFirstChar];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        [backingStore setObject:value forKey:key];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [backingStore removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用它们的方式很简单:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AutoDictionary *dict = [[AutoDictionary alloc] init];</span><br><span class="line">dict.date = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:<span class="number">475372800</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"dict.date = %@"</span>, dict.date);</span><br><span class="line"><span class="comment">//Output: dict.date = 1985-01-24 00:00:00 +0000</span></span><br></pre></td></tr></table></figure>
<p>而且它还是<strong>KVC兼容</strong>的哦! <em>(关于KVC与KVO, 可参考我<a href="(http://partyspy.cn/2016/06/30/KVC%20&amp;%20KVO%20%E5%B0%8F%E7%BB%93/">之前的博客</a>))</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[dict setValue:<span class="string">@"I'm a string!"</span> forKey:<span class="string">@"string"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"dict.string = %@"</span>, dict.string);</span><br><span class="line"><span class="comment">//Output: dict.string = I'm a string!</span></span><br></pre></td></tr></table></figure>
<h3 id="备援接受者"><a href="#备援接受者" class="headerlink" title="备援接受者"></a>备援接受者</h3><p>在完整的消息转发来临之前, 当前接受者还有第二次机会处理未知的选择子. 处理方法如下:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>
<p>运行时系统通过该方法询问能否把无法识别的选择子转给其它对象处理呢?<br>例如, 在一个对象内部, 可能还有其它一系列对象, 该对象可经由此方法将能够处理某选择子的相关内部对象返回. 这样看来, 就好像是该对象亲自处理了这些消息似的. 这样可以模拟出<strong>“多重继承”</strong>的特性.</p>
<h3 id="完整的消息转发"><a href="#完整的消息转发" class="headerlink" title="完整的消息转发"></a>完整的消息转发</h3><p>终于来到了这一步. 首先创建<code>NSInvocation</code>对象, 把尚未处理的有关该消息的全部细节封装起来, 包括选择子, 目标(target), 参数与返回值等. 在触发<code>NSInvocation</code>对象时, 消息派发系统(message-dispatch system)将亲自出马, 把消息指派给目标对象.</p>
<p>消息转发方法:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br></pre></td></tr></table></figure>
<p>在此方法里需要做的事情是:</p>
<ul>
<li>决定消息发送的目标对象;</li>
<li>随参数一起发送该消息.</li>
</ul>
<p>消息通过<code>invokeWithTarget:</code>发送.</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject respondsToSelector:</span><br><span class="line">            [anInvocation selector]])</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中最后调用超类处理该消息, 沿着继承体系向上, 每个类都有机会处理该请求, 直至NSObject, 它的该方法默认实现为抛出<code>doesNotRecognizeSelector:</code>异常.</p>
<p>相对于简单的消息发送语句 <code>[receiver message];</code>, <code>forwardInvocation:</code>提供了一种更加灵活的机制, 避免了冗余的方法重写或者破坏类继承体系, 而提供了一种类似”<em>消息中转派发</em>“的机制. 另外NSInvocation也提供了对待转发消息的修改机制, 甚至不做转发, 等等, 也提供了更多的操作性. </p>
<p>初探Objective-C Runtime System, 这篇博文对Runtime消息传递, 转发机制等做了一些探讨. 关于更多的Runtime研究与实践, 将在日后的博客中更新.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1" target="_blank" rel="external">Objective-C Runtime Programming Guide</a></li>
<li><a href="http://www.effectiveobjectivec.com/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/07/20/利用AFNetworking最小代码实现自签CA证书的HTTPS/" class="prev">PREV</a><a href="/2016/06/30/KVC &amp; KVO 小结/" class="next">NEXT</a></div><div data-thread-key="2016/07/02/Objective-C Rumtime(一)- 初探/" data-title="Objective-C Runtime(一) 初探" data-url="http://yoursite.com/2016/07/02/Objective-C Rumtime(一)- 初探/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"partyspy"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">partyspy</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>